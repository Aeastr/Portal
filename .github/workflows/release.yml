name: Release

on:
  pull_request:
    types: [closed]
    branches: [ main ]

# Prevent concurrent releases
concurrency:
  group: release
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: read

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.pull_request.merged == true

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.pull_request.merge_commit_sha }}
        # Fetch full history for changelog generation
        fetch-depth: 0

    - name: Extract and validate version from PR title
      id: version
      shell: bash
      run: |
        PR_TITLE="${{ github.event.pull_request.title }}"
        echo "PR Title: $PR_TITLE"

        # Extract version number (supports formats like "4.3.0", "Release 4.3.0", "v4.3.0")
        VERSION=$(echo "$PR_TITLE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)

        if [ -z "$VERSION" ]; then
          echo "::error::No version number found in PR title '$PR_TITLE'. Expected format: '4.3.0' or 'Release 4.3.0'"
          exit 1
        fi

        # Validate semantic versioning format (MAJOR.MINOR.PATCH)
        if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
          echo "::error::Version '$VERSION' is not valid semantic versioning (expected: MAJOR.MINOR.PATCH)"
          exit 1
        fi

        echo "Extracted version: $VERSION"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$VERSION" >> $GITHUB_OUTPUT
        echo "release_name=$PR_TITLE" >> $GITHUB_OUTPUT

    - name: Generate changelog from commits
      id: changelog
      shell: bash
      run: |
        TAG="${{ steps.version.outputs.tag }}"

        # Get the previous release tag
        PREV_TAG=$(git tag -l --sort=-v:refname | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | head -1)

        if [ -n "$PREV_TAG" ]; then
          echo "Generating changelog from $PREV_TAG to HEAD"

          # Generate changelog from commits
          CHANGELOG=$(git log $PREV_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges)

          if [ -n "$CHANGELOG" ]; then
            echo "## Changes since $PREV_TAG" > changelog.txt
            echo "" >> changelog.txt
            echo "$CHANGELOG" >> changelog.txt
          else
            echo "::warning::No commits found between $PREV_TAG and HEAD"
            echo "::warning::Creating a release with no changes. Verify this is intentional."
            echo "## Changes since $PREV_TAG" > changelog.txt
            echo "" >> changelog.txt
            echo "_No new commits since last release_" >> changelog.txt
          fi
        else
          echo "## Initial Release" > changelog.txt
          echo "" >> changelog.txt
          echo "First release of Portal" >> changelog.txt
        fi

        cat changelog.txt

    - name: Validate and merge release notes
      id: notes
      shell: bash
      run: |
        PR_BODY="${{ github.event.pull_request.body }}"

        # Check if PR body is empty or only whitespace
        if [ -z "$(echo "$PR_BODY" | tr -d '[:space:]')" ]; then
          echo "::warning::PR body is empty. Using generated changelog only."
          cat changelog.txt > release_notes.txt
        else
          # Combine PR body with generated changelog
          echo "$PR_BODY" > release_notes.txt
          echo "" >> release_notes.txt
          echo "---" >> release_notes.txt
          echo "" >> release_notes.txt
          cat changelog.txt >> release_notes.txt
        fi

        # Save to output with unique delimiter to prevent EOF collision
        DELIMITER="EOF_$(date +%s)_$$"
        echo "notes<<$DELIMITER" >> $GITHUB_OUTPUT
        cat release_notes.txt >> $GITHUB_OUTPUT
        echo "$DELIMITER" >> $GITHUB_OUTPUT

    - name: Check if tag exists on remote
      shell: bash
      run: |
        TAG="${{ steps.version.outputs.tag }}"

        # Fetch tags from remote
        git fetch --tags

        # Check if tag exists remotely
        if git ls-remote --tags origin | grep -q "refs/tags/$TAG"; then
          echo "::error::Tag $TAG already exists on remote"
          exit 1
        fi

        echo "Tag $TAG is available"

    - name: Validate version is greater than latest release
      shell: bash
      run: |
        CURRENT_VERSION="${{ steps.version.outputs.version }}"

        # Get latest release tag
        LATEST_TAG=$(git tag -l --sort=-v:refname | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | head -1)

        if [ -n "$LATEST_TAG" ]; then
          echo "Latest release: $LATEST_TAG"
          echo "New version: $CURRENT_VERSION"

          # Version comparison (works for semantic versioning)
          if [ "$(printf '%s\n' "$LATEST_TAG" "$CURRENT_VERSION" | sort -V | tail -1)" != "$CURRENT_VERSION" ]; then
            echo "::error::Version $CURRENT_VERSION must be greater than latest release $LATEST_TAG"
            echo "::error::Cannot downgrade or create duplicate versions"
            exit 1
          fi

          echo "✓ Version $CURRENT_VERSION is valid (> $LATEST_TAG)"
        else
          echo "No previous releases found - this will be the first release"
        fi

    - name: Create and push tag
      id: create_tag
      shell: bash
      run: |
        TAG="${{ steps.version.outputs.tag }}"

        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Create annotated tag
        git tag -a "$TAG" -m "Release ${{ steps.version.outputs.version }}"

        # Push tag with retry logic
        MAX_RETRIES=3
        RETRY_COUNT=0

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if git push origin "$TAG"; then
            echo "Successfully pushed tag $TAG"
            echo "success=true" >> $GITHUB_OUTPUT
            exit 0
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Failed to push tag (attempt $RETRY_COUNT/$MAX_RETRIES)"
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              sleep 2
            fi
          fi
        done

        echo "::error::Failed to push tag after $MAX_RETRIES attempts"
        echo "success=false" >> $GITHUB_OUTPUT

        # Clean up local tag on failure
        git tag -d "$TAG"
        exit 1

    - name: Create GitHub Release
      id: create_release
      if: steps.create_tag.outputs.success == 'true'
      shell: bash
      run: |
        TAG="${{ steps.version.outputs.tag }}"
        RELEASE_NAME="${{ steps.version.outputs.release_name }}"

        # Create release using GitHub CLI
        gh release create "$TAG" \
          --title "$RELEASE_NAME" \
          --notes "${{ steps.notes.outputs.notes }}" \
          --verify-tag

        echo "success=true" >> $GITHUB_OUTPUT
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on success
      if: steps.create_release.outputs.success == 'true'
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.tag }}"

        # Comment on PR with success notification
        gh pr comment "${{ github.event.pull_request.number }}" \
          --body "✅ **Release $VERSION created successfully!**

        View the release: [$VERSION]($RELEASE_URL)

        The release is now available via Swift Package Manager."
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Cleanup on failure
      if: failure() && steps.create_tag.outputs.success == 'true'
      shell: bash
      run: |
        TAG="${{ steps.version.outputs.tag }}"
        echo "::warning::Release creation failed. Cleaning up tag $TAG"

        # Delete remote tag
        git push --delete origin "$TAG" || echo "Failed to delete remote tag"

        echo "::error::Release creation failed. Tag has been cleaned up. Please retry the release."

    - name: Notify on failure
      if: failure()
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        PR_URL="${{ github.event.pull_request.html_url }}"
        RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

        echo "::error::Release workflow failed for version $VERSION"
        echo "::error::PR: $PR_URL"
        echo "::error::Workflow run: $RUN_URL"
        echo "::error::Please check the logs and retry the release"

        # Create an issue comment to notify about the failure
        gh pr comment "${{ github.event.pull_request.number }}" \
          --body "⚠️ **Release workflow failed for version $VERSION**

        The automated release process encountered an error. Please check the [workflow logs]($RUN_URL) for details.

        Common issues:
        - Tag already exists
        - Invalid version format
        - Network/permission issues

        You may need to manually create the release or re-trigger the workflow."
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
